# -*- coding: utf-8 -*-
"""Cat-Vs-Dog-Classification.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cIlt6961D8fxxUSA1VcF7CFun5gSBYk3
"""

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/

!kaggle datasets download -d salader/dogs-vs-cats

import zipfile
zip_ref = zipfile.ZipFile('/content/dogs-vs-cats.zip', 'r')
zip_ref.extractall('/content')
zip_ref.close()

import tensorflow as tf
from tensorflow import keras
from keras import Sequential
from keras.layers import Dense, Conv2D, MaxPooling2D, Flatten, BatchNormalization, Dropout

# generators
train_ds = keras.utils.image_dataset_from_directory(
    directory='/content/train',
    labels='inferred',
    label_mode='int',
    batch_size=32,
    image_size=(256, 256)
)

class_names = train_ds.class_names
print("Class names:", class_names)

validation_ds = keras.utils.image_dataset_from_directory(
    directory='/content/test',
    labels='inferred',
    label_mode='int',
    batch_size=32,
    image_size=(256, 256)
)

# Normalize
def process(image, label):
  image = tf.cast(image/255. , tf.float32)
  return image, label

train_ds = train_ds.map(process)
validation_ds = validation_ds.map(process)

# create CNN model

model = Sequential()

model.add(Conv2D(32, kernel_size=(3,3), padding='valid', activation='relu', input_shape=(256,256,3)))
model.add(BatchNormalization())
model.add(MaxPooling2D(pool_size=(2,2), strides=2, padding='valid'))

model.add(Conv2D(64, kernel_size=(3,3), padding='valid', activation='relu', input_shape=(256,256,3)))
model.add(BatchNormalization())
model.add(MaxPooling2D(pool_size=(2,2), strides=2, padding='valid'))

model.add(Conv2D(128, kernel_size=(3,3), padding='valid', activation='relu', input_shape=(256,256,3)))
model.add(BatchNormalization())
model.add(MaxPooling2D(pool_size=(2,2), strides=2, padding='valid'))

model.add(Flatten())

model.add(Dense(128, activation='relu'))
model.add(Dropout(0.1))
model.add(Dense(64, activation='relu'))
model.add(Dropout(0.1))
model.add(Dense(1, activation='sigmoid'))

model.summary()

model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

history = model.fit(train_ds,epochs = 10,validation_data = validation_ds)

import matplotlib.pyplot as plt

plt.plot(history.history['accuracy'], color='red', label='train')
plt.plot(history.history['val_accuracy'], color='blue', label='validation')
plt.legend()
plt.show()

plt.plot(history.history['loss'], color='red', label='train')
plt.plot(history.history['val_loss'], color='blue', label='validation')
plt.legend()
plt.show()

#Ways to reduce Over-Fitting

# Add more data
# Data Augmentation
# L1/L2 Regularizer
# Dropout
# Batch Norm
# Reduce complexity

import cv2

test_img = cv2.imread('/content/dog.jpg')

plt.imshow(test_img)

test_img.shape

test_img = cv2.resize(test_img, (256,256))

test_input = test_img.reshape((1,256,256,3))

pred = model.predict(test_input)[0][0]  # Get scalar
predicted_class = class_names[1] if pred >= 0.5 else class_names[0]
confidence = pred if pred >= 0.5 else 1 - pred

print(f"Prediction: {predicted_class} ({confidence*100:.2f}%)")

model.save('dogCatClassification.h5')

from tensorflow.keras.models import load_model

model = load_model('dogCatClassification.h5')

import gradio as gr
import numpy as np
from PIL import Image

# ‚úÖ Load your model
model = tf.keras.models.load_model('/content/dogCatClassification.h5')

class_names = ['cat','dog']

def predict_image(img):
    img = img.convert("RGB")  # In case it comes as RGBA or grayscale
    img = img.resize((256, 256))
    img_array = np.array(img) / 255.0
    img_array = np.expand_dims(img_array, axis=0)

    predictions = model.predict(img_array)

    # üîç If using sigmoid + Dense(1):
    if predictions.shape[1] == 1:
        predicted_class = class_names[0] if predictions[0][0] < 0.5 else class_names[1]
        confidence = predictions[0][0] if predictions[0][0] > 0.5 else 1 - predictions[0][0]

    # üîç If using softmax + Dense(2):
    else:
        predicted_class = class_names[np.argmax(predictions)]
        confidence = np.max(predictions)

    return f"{predicted_class} ({confidence*100:.2f}%)"

interface = gr.Interface(
    fn=predict_image,
    inputs=gr.Image(type="pil"),
    outputs="text",
    title="Dog or Cat Classifier",
    description="Upload an image of a cat or dog. Other images may be flagged as 'Uncertain'."
)

interface.launch(share=True)

model.evaluate(validation_ds)